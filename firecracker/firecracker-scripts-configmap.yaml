apiVersion: v1
kind: ConfigMap
metadata:
  name: firecracker-scripts
  namespace: arc-systems
data:
  firecracker-complete.sh: |
    #!/bin/bash
    # firecracker-complete.sh - Complete Firecracker VM Management Script
    # This script manages Firecracker VMs with host bridge networking

    set -euo pipefail

    # Configuration
    WORK_DIR="/opt/firecracker"
    VM_DIR="$WORK_DIR/vms"
    KERNEL_PATH="$WORK_DIR/vmlinux.bin"
    ROOTFS_PATH="$WORK_DIR/rootfs.ext4"
    FIRECRACKER_BIN="/usr/local/bin/firecracker"
    GITHUB_ACTIONS_DIR="/opt/actions-runner"

    # Enhanced logging function
    log() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$$] $*" >&2
        # Also log to a file if possible
        if [[ -w "/opt/firecracker/logs" ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$$] $*" >> "/opt/firecracker/logs/script.log"
        fi
    }

    # Debug logging function
    debug() {
        log "DEBUG: $*"
    }

    # Info logging function
    info() {
        log "INFO: $*"
    }

    # Warning logging function
    warn() {
        log "WARNING: $*"
    }

    # Error handling
    error_exit() {
        log "ERROR: $1"
        exit 1
    }

    # Function to log environment and system info
    log_system_info() {
        debug "=== SYSTEM INFORMATION ==="
        debug "Script: $0"
        debug "Arguments: $*"
        debug "Working directory: $(pwd)"
        debug "User: $(whoami)"
        debug "UID: $(id -u)"
        debug "GID: $(id -g)"
        debug "Groups: $(groups)"
        debug "Environment variables:"
        debug "  PATH=${PATH:-NOT_SET}"
        debug "  USER=${USER:-NOT_SET}"
        debug "  HOME=${HOME:-NOT_SET}"
        debug "  SHELL=${SHELL:-NOT_SET}"
        debug "Available disk space:"
        df -h || debug "Could not get disk info"
        debug "Available memory:"
        free -h || debug "Could not get memory info"
        debug "Network interfaces:"
        ip link show || debug "Could not get network interfaces"
        debug "Bridge status:"
        brctl show || debug "Could not get bridge info"
        debug "=========================="
    }

    # Check if running as root
    check_root() {
        debug "Checking if running as root..."
        if [[ $EUID -ne 0 ]]; then
            error_exit "This script must be run as root for bridge networking (current UID: $EUID)"
        fi
        info "Running as root ✓"
    }

    # Initialize working directory
    init_work_dir() {
        info "Initializing working directory: $WORK_DIR"
        debug "Creating directories: $VM_DIR, $GITHUB_ACTIONS_DIR"
        mkdir -p "$VM_DIR" "$GITHUB_ACTIONS_DIR" "/opt/firecracker/logs"
        
        cd "$WORK_DIR"
        info "Changed to working directory: $(pwd)"
        
        debug "Directory contents:"
        ls -la "$WORK_DIR" || debug "Could not list working directory"
        
        debug "VM directory contents:"
        ls -la "$VM_DIR" || debug "Could not list VM directory"
    }

    # Download kernel if needed
    download_kernel() {
        info "Checking kernel availability: $KERNEL_PATH"
        if [[ ! -f "$KERNEL_PATH" ]]; then
            info "Kernel not found, downloading..."
            debug "Using wget to download kernel from AWS S3"
            if wget -q -O "$KERNEL_PATH" https://s3.amazonaws.com/spec.ccfc.min/img/quickstart_guide/x86_64/kernels/vmlinux.bin; then
                info "Kernel downloaded successfully"
                debug "Kernel file size: $(ls -lh "$KERNEL_PATH" | awk '{print $5}')"
            else
                error_exit "Failed to download kernel"
            fi
        else
            info "Kernel already exists ✓"
            debug "Kernel file size: $(ls -lh "$KERNEL_PATH" | awk '{print $5}')"
        fi
    }

    # Download rootfs if needed
    download_rootfs() {
        info "Checking rootfs availability: $ROOTFS_PATH"
        if [[ ! -f "$ROOTFS_PATH" ]]; then
            info "Rootfs not found, downloading..."
            debug "Using wget to download rootfs from AWS S3"
            if wget -q -O "$ROOTFS_PATH" https://s3.amazonaws.com/spec.ccfc.min/img/quickstart_guide/x86_64/rootfs/ubuntu-18.04.ext4; then
                info "Rootfs downloaded successfully"
                debug "Rootfs file size: $(ls -lh "$ROOTFS_PATH" | awk '{print $5}')"
            else
                error_exit "Failed to download rootfs"
            fi
        else
            info "Rootfs already exists ✓"
            debug "Rootfs file size: $(ls -lh "$ROOTFS_PATH" | awk '{print $5}')"
        fi
    }

    # Create TAP interface for VM
    create_tap_interface() {
        local vm_name="$1"
        info "Creating TAP interface for VM: $vm_name"
        
        # Truncate vm_name to ensure tap name is <= 15 chars (tap- is 4 chars, so vm_name max 11)
        local truncated_name="${vm_name:0:11}"
        local tap_name="tap-${truncated_name}"
        
        debug "VM name: $vm_name"
        debug "Truncated name: $truncated_name"
        debug "TAP interface name: $tap_name"
        debug "TAP name length: ${#tap_name}"
        
        if ! ip link show "$tap_name" >/dev/null 2>&1; then
            info "Creating TAP interface: $tap_name"
            debug "Running: ip tuntap add \"$tap_name\" mode tap"
            if ip tuntap add "$tap_name" mode tap; then
                info "TAP interface created successfully"
            else
                error_exit "Failed to create TAP interface $tap_name"
            fi
            
            debug "Setting TAP interface up"
            if ip link set "$tap_name" up; then
                info "TAP interface brought up successfully"
            else
                error_exit "Failed to bring up TAP interface $tap_name"
            fi
            
            # Add to host bridge br0
            if ip link show br0 >/dev/null 2>&1; then
                info "Bridge br0 found, adding TAP interface"
                debug "Running: ip link set \"$tap_name\" master br0"
                if ip link set "$tap_name" master br0; then
                    info "Added $tap_name to bridge br0 ✓"
                else
                    warn "Failed to add $tap_name to bridge br0"
                fi
            else
                warn "Bridge br0 not found, TAP interface created but not bridged"
                debug "Available bridges:"
                brctl show || debug "Could not list bridges"
            fi
        else
            info "TAP interface $tap_name already exists"
        fi
        
        debug "Final TAP interface status:"
        ip link show "$tap_name" >&2 || debug "Could not show TAP interface"
        
        echo "$tap_name"
    }

    # Remove TAP interface
    remove_tap_interface() {
        local tap_name="$1"
        info "Removing TAP interface: $tap_name"
        
        if ip link show "$tap_name" >/dev/null 2>&1; then
            debug "TAP interface exists, deleting..."
            if ip link delete "$tap_name"; then
                info "TAP interface $tap_name removed successfully"
            else
                warn "Failed to remove TAP interface $tap_name"
            fi
        else
            debug "TAP interface $tap_name does not exist"
        fi
    }

    # Create VM configuration
    create_vm_config() {
        local vm_name="$1"
        local memory_mb="${2:-8192}"
        local vcpus="${3:-4}"
        local tap_name="$4"
        
        info "Creating VM configuration for: $vm_name"
        debug "Memory: ${memory_mb}MB"
        debug "vCPUs: $vcpus"
        debug "TAP interface: $tap_name"
        debug "Kernel path: $KERNEL_PATH"
        debug "Rootfs path: $ROOTFS_PATH"
        
        local config_file="$VM_DIR/${vm_name}.json"
        info "Configuration file: $config_file"
        
        debug "Writing VM configuration..."
        cat > "$config_file" << EOF
    {
      "boot-source": {
        "kernel_image_path": "$KERNEL_PATH",
        "boot_args": "console=ttyS0 reboot=k panic=1 root=/dev/vda rw"
      },
      "drives": [
        {
          "drive_id": "rootfs",
          "path_on_host": "$ROOTFS_PATH",
          "is_root_device": true,
          "is_read_only": false
        }
      ],
      "machine-config": {
        "vcpu_count": $vcpus,
        "mem_size_mib": $memory_mb,
        "smt": false
      },
      "network-interfaces": [
        {
          "iface_id": "eth0",
          "guest_mac": "AA:FC:00:00:00:01",
          "host_dev_name": "$tap_name"
        }
      ]
    }
    EOF
        
        if [[ -f "$config_file" ]]; then
            info "Configuration file created successfully"
            debug "Configuration file size: $(ls -lh "$config_file" | awk '{print $5}')"
            debug "Configuration contents:"
            cat "$config_file" | while IFS= read -r line; do
                debug "  $line"
            done
        else
            error_exit "Failed to create configuration file"
        fi
        
        echo "$config_file"
    }

    # Launch VM
    launch_vm() {
        local vm_name="$1"
        local memory_mb="${2:-8192}"
        local vcpus="${3:-4}"
        local github_url="${4:-}"
        local github_token="${5:-}"
        local labels="${6:-firecracker}"
        
        info "=== LAUNCHING VM: $vm_name ==="
        debug "Parameters:"
        debug "  VM name: $vm_name"
        debug "  Memory: ${memory_mb}MB"
        debug "  vCPUs: $vcpus"
        debug "  GitHub URL: $github_url"
        debug "  GitHub token length: ${#github_token}"
        debug "  Labels: $labels"
        
        log_system_info "$@"
        
        check_root
        init_work_dir
        download_kernel
        download_rootfs
        
        info "Starting VM creation process..."
        
        # Create TAP interface
        info "Step 1: Creating TAP interface"
        local tap_name
        tap_name=$(create_tap_interface "$vm_name")
        debug "TAP interface created: $tap_name"
        
        # Create VM configuration
        info "Step 2: Creating VM configuration"
        local config_file
        config_file=$(create_vm_config "$vm_name" "$memory_mb" "$vcpus" "$tap_name")
        debug "Configuration file created: $config_file"
        
        # Create socket path
        local socket_path="$VM_DIR/${vm_name}.socket"
        info "Step 3: Preparing Firecracker socket: $socket_path"
        
        # Remove existing socket if it exists
        if [[ -S "$socket_path" ]]; then
            debug "Removing existing socket: $socket_path"
            rm -f "$socket_path"
        fi
        
        # Check if Firecracker binary exists
        info "Step 4: Checking Firecracker binary"
        if [[ ! -x "$FIRECRACKER_BIN" ]]; then
            error_exit "Firecracker binary not found or not executable: $FIRECRACKER_BIN"
        else
            info "Firecracker binary found ✓"
            debug "Firecracker version:"
            "$FIRECRACKER_BIN" --version || debug "Could not get Firecracker version"
        fi
        
        # Launch Firecracker
        info "Step 5: Launching Firecracker process"
        debug "Command: $FIRECRACKER_BIN --api-sock \"$socket_path\" --config-file \"$config_file\""
        
        # Redirect stdout and stderr to log files
        local vm_log="$VM_DIR/${vm_name}.log"
        local vm_err="$VM_DIR/${vm_name}.err"
        
        info "VM logs will be written to:"
        info "  STDOUT: $vm_log"
        info "  STDERR: $vm_err"
        
        debug "Starting Firecracker in background..."
        if "$FIRECRACKER_BIN" --api-sock "$socket_path" --config-file "$config_file" > "$vm_log" 2> "$vm_err" &
        then
            local fc_pid=$!
            info "Firecracker process started with PID: $fc_pid"
            
            # Wait a moment for the process to start
            sleep 2
            
            # Check if process is still running
            if kill -0 "$fc_pid" 2>/dev/null; then
                info "Firecracker process is running ✓"
            else
                error_exit "Firecracker process died immediately. Check logs: $vm_err"
            fi
            
            # Wait for socket to be created
            debug "Waiting for API socket to be created..."
            local wait_count=0
            while [[ ! -S "$socket_path" && $wait_count -lt 30 ]]; do
                sleep 0.5
                ((wait_count++))
                debug "Waiting for socket... ($wait_count/30)"
            done
            
            if [[ -S "$socket_path" ]]; then
                info "API socket created successfully ✓"
                debug "Socket permissions: $(ls -l "$socket_path")"
            else
                warn "API socket was not created within 15 seconds"
            fi
            
            # Store VM metadata
            local meta_file="$VM_DIR/${vm_name}.meta"
            info "Step 6: Storing VM metadata: $meta_file"
            
            debug "Writing metadata..."
            cat > "$meta_file" << EOF
    VM_NAME=$vm_name
    PID=$fc_pid
    SOCKET=$socket_path
    TAP_INTERFACE=$tap_name
    MEMORY_MB=$memory_mb
    VCPUS=$vcpus
    GITHUB_URL=$github_url
    GITHUB_TOKEN=$github_token
    LABELS=$labels
    CREATED=$(date -Iseconds)
    CONFIG_FILE=$config_file
    LOG_FILE=$vm_log
    ERR_FILE=$vm_err
    EOF
            
            if [[ -f "$meta_file" ]]; then
                info "Metadata file created successfully"
                debug "Metadata contents:"
                cat "$meta_file" | while IFS= read -r line; do
                    debug "  $line"
                done
            else
                warn "Failed to create metadata file"
            fi
            
            # Final status check
            info "Step 7: Final status verification"
            if kill -0 "$fc_pid" 2>/dev/null; then
                info "VM $vm_name launched successfully! ✓"
                info "Process ID: $fc_pid"
                info "TAP interface: $tap_name"
                info "API socket: $socket_path"
                
                # Show initial logs
                debug "Initial VM logs (stdout):"
                if [[ -f "$vm_log" ]]; then
                    head -20 "$vm_log" | while IFS= read -r line; do
                        debug "  STDOUT: $line"
                    done
                fi
                
                debug "Initial VM errors (stderr):"
                if [[ -f "$vm_err" ]]; then
                    head -20 "$vm_err" | while IFS= read -r line; do
                        debug "  STDERR: $line"
                    done
                fi
                
                echo "VM launched: $vm_name (PID: $fc_pid, TAP: $tap_name)"
            else
                error_exit "VM process died after launch. Check logs: $vm_err"
            fi
        else
            error_exit "Failed to start Firecracker process"
        fi
    }

    # Stop VM
    stop_vm() {
        local vm_name="$1"
        local meta_file="$VM_DIR/${vm_name}.meta"
        
        info "=== STOPPING VM: $vm_name ==="
        
        if [[ ! -f "$meta_file" ]]; then
            error_exit "VM $vm_name not found (no metadata file: $meta_file)"
        fi
        
        info "Loading VM metadata from: $meta_file"
        source "$meta_file"
        
        debug "VM metadata loaded:"
        debug "  PID: $PID"
        debug "  TAP interface: $TAP_INTERFACE"
        debug "  Socket: $SOCKET"
        
        info "Stopping VM process (PID: $PID)"
        
        # Kill Firecracker process
        if kill -0 "$PID" 2>/dev/null; then
            debug "Process is running, sending TERM signal"
            if kill -TERM "$PID" 2>/dev/null; then
                info "TERM signal sent"
                sleep 2
                if kill -0 "$PID" 2>/dev/null; then
                    warn "Process still running, sending KILL signal"
                    kill -KILL "$PID"
                else
                    info "Process terminated gracefully"
                fi
            else
                warn "Failed to send TERM signal"
            fi
        else
            info "Process not running"
        fi
        
        # Remove TAP interface
        remove_tap_interface "$TAP_INTERFACE"
        
        # Clean up files
        info "Cleaning up VM files"
        local files_to_remove=(
            "$VM_DIR/${vm_name}."*
        )
        
        for file_pattern in "${files_to_remove[@]}"; do
            if ls $file_pattern >/dev/null 2>&1; then
                debug "Removing: $file_pattern"
                rm -f $file_pattern
            fi
        done
        
        info "VM $vm_name stopped successfully ✓"
    }

    # List VMs
    list_vms() {
        info "=== LISTING FIRECRACKER VMs ==="
        
        if [[ ! -d "$VM_DIR" ]]; then
            warn "VM directory does not exist: $VM_DIR"
            echo "No VMs found (VM directory does not exist)"
            return
        fi
        
        debug "Scanning VM directory: $VM_DIR"
        local found_vms=false
        for meta_file in "$VM_DIR"/*.meta; do
            if [[ -f "$meta_file" ]]; then
                found_vms=true
                debug "Processing metadata file: $meta_file"
                source "$meta_file"
                local status="unknown"
                if kill -0 "$PID" 2>/dev/null; then
                    status="running"
                    debug "VM $VM_NAME: Process $PID is running"
                else
                    status="stopped"
                    debug "VM $VM_NAME: Process $PID is not running"
                fi
                
                echo "VM: $VM_NAME"
                echo "  Status: $status"
                echo "  PID: $PID"
                echo "  TAP: $TAP_INTERFACE"
                echo "  Memory: ${MEMORY_MB}MB"
                echo "  vCPUs: $VCPUS"
                echo "  Created: $CREATED"
                echo "  GitHub URL: $GITHUB_URL"
                echo "  Labels: $LABELS"
                echo
            fi
        done
        
        if [[ "$found_vms" == false ]]; then
            info "No VM metadata files found"
            echo "No VMs found"
        fi
    }

    # Get VM status
    vm_status() {
        local vm_name="$1"
        local meta_file="$VM_DIR/${vm_name}.meta"
        
        info "Getting status for VM: $vm_name"
        debug "Metadata file: $meta_file"
        
        if [[ ! -f "$meta_file" ]]; then
            warn "VM metadata not found: $meta_file"
            echo "VM $vm_name not found"
            return 1
        fi
        
        source "$meta_file"
        debug "Checking process $PID"
        
        if kill -0 "$PID" 2>/dev/null; then
            info "VM $vm_name is running (PID: $PID)"
            echo "VM $vm_name is running (PID: $PID)"
        else
            info "VM $vm_name is stopped"
            echo "VM $vm_name is stopped"
        fi
    }

    # Show usage
    usage() {
        cat << EOF
    Usage: $0 <command> [options]

    Commands:
      launch <name> [options]    Launch a new VM
      stop <name>               Stop a VM
      list                      List all VMs
      status <name>             Show VM status

    Launch Options:
      --memory <MB>             Memory in MB (default: 8192)
      --cpus <count>            vCPU count (default: 4)
      --github-url <url>        GitHub repository URL
      --github-token <token>    GitHub access token
      --labels <labels>         Runner labels (default: firecracker)
      --use-host-bridge         Use host bridge networking (default)
      --arc-mode                ARC controller integration mode
      --arc-controller-url <url> ARC controller URL
      --ephemeral-mode          Ephemeral VM mode

    Examples:
      $0 launch vm1 --memory 4096 --cpus 2
      $0 launch vm2 --github-url https://github.com/user/repo --github-token ghp_xxx
      $0 stop vm1
      $0 list
      $0 status vm1
    EOF
    }

    # Main command dispatch
    main() {
        info "=== FIRECRACKER SCRIPT STARTING ==="
        info "Command line: $0 $*"
        
        case "${1:-}" in
            launch)
                if [[ $# -lt 2 ]]; then
                    warn "Insufficient arguments for launch command"
                    usage
                    exit 1
                fi
                
                local vm_name="$2"
                local memory_mb=8192
                local vcpus=4
                local github_url=""
                local github_token=""
                local labels="firecracker"
                
                info "Parsing launch arguments..."
                debug "VM name: $vm_name"
                
                shift 2
                while [[ $# -gt 0 ]]; do
                    debug "Processing argument: $1"
                    case $1 in
                        --memory)
                            memory_mb="$2"
                            debug "Memory set to: $memory_mb"
                            shift 2
                            ;;
                        --cpus)
                            vcpus="$2"
                            debug "vCPUs set to: $vcpus"
                            shift 2
                            ;;
                        --github-url)
                            github_url="$2"
                            debug "GitHub URL set to: $github_url"
                            shift 2
                            ;;
                        --github-token)
                            github_token="$2"
                            debug "GitHub token set (length: ${#github_token})"
                            shift 2
                            ;;
                        --labels)
                            labels="$2"
                            debug "Labels set to: $labels"
                            shift 2
                            ;;
                        --use-host-bridge|--arc-mode|--ephemeral-mode)
                            debug "Flag processed: $1"
                            # Flags that don't need values
                            shift
                            ;;
                        --arc-controller-url)
                            debug "ARC controller URL: $2 (skipped)"
                            # Skip ARC controller URL for now
                            shift 2
                            ;;
                        --name)
                            # Handle --name flag
                            vm_name="$2"
                            debug "VM name updated to: $vm_name"
                            shift 2
                            ;;
                        *)
                            warn "Unknown option: $1"
                            usage
                            exit 1
                            ;;
                    esac
                done
                
                info "Final parameters:"
                info "  VM name: $vm_name"
                info "  Memory: ${memory_mb}MB"
                info "  vCPUs: $vcpus"
                info "  GitHub URL: $github_url"
                info "  GitHub token: ${#github_token} characters"
                info "  Labels: $labels"
                
                launch_vm "$vm_name" "$memory_mb" "$vcpus" "$github_url" "$github_token" "$labels"
                ;;
            stop)
                if [[ $# -ne 2 ]]; then
                    warn "Stop command requires exactly one VM name"
                    usage
                    exit 1
                fi
                stop_vm "$2"
                ;;
            list)
                list_vms
                ;;
            status)
                if [[ $# -ne 2 ]]; then
                    warn "Status command requires exactly one VM name"
                    usage
                    exit 1
                fi
                vm_status "$2"
                ;;
            *)
                warn "Unknown command: ${1:-<empty>}"
                usage
                exit 1
                ;;
        esac
        
        info "=== FIRECRACKER SCRIPT COMPLETED ==="
    }

    # Run main function
    main "$@"

  firecracker-vm-daemon.py: |
    #!/usr/bin/env python3
    """
    Firecracker VM Daemon - Host-based VM management API
    Wraps firecracker-complete.sh for Kubernetes integration
    """

    import os
    import json
    import subprocess
    import threading
    import time
    import re
    import glob
    from datetime import datetime
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from urllib.parse import urlparse, parse_qs
    import logging

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    class FirecrackerVMDaemon:
        def __init__(self, work_dir="/opt/firecracker", script_path="/usr/local/bin/firecracker-complete.sh"):
            self.work_dir = work_dir
            self.script_path = script_path
            self.vms = {}  # Track VM state
            self.vm_logs = {}  # Track VM startup logs
            self.metrics = {
                "total_vms_created": 0,
                "total_vms_deleted": 0,
                "current_vms": 0,
                "failed_creations": 0,
                "daemon_start_time": datetime.now().isoformat()
            }
            
            # Ensure directories exist
            os.makedirs(work_dir, exist_ok=True)
            os.chdir(work_dir)
            
            logger.info(f"Firecracker VM Daemon starting in {work_dir}")
            logger.info(f"Using script: {script_path}")

        def sanitize_output(self, text):
            """Remove sensitive information from output"""
            if not text:
                return text
            
            # Remove GitHub tokens
            text = re.sub(r'gh[pousr]_[A-Za-z0-9]{36}', '[TOKEN_HIDDEN]', text)
            text = re.sub(r'BNNAW[A-Z0-9]{60,}', '[TOKEN_HIDDEN]', text)
            text = re.sub(r'"github_token":\s*"[^"]{20,}"', '"github_token": "[HIDDEN]"', text)
            text = re.sub(r'--github-token\s+[^\s]+', '--github-token [HIDDEN]', text)
            
            return text

        def execute_script(self, args, timeout=300):
            """Execute firecracker-complete.sh with given arguments"""
            cmd = [self.script_path] + args
            logger.info(f"Executing: {self.sanitize_output(' '.join(cmd))}")
            
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    cwd=self.work_dir
                )
                
                # Sanitize outputs
                sanitized_result = {
                    "success": result.returncode == 0,
                    "returncode": result.returncode,
                    "stdout": self.sanitize_output(result.stdout),
                    "stderr": self.sanitize_output(result.stderr)
                }
                
                return sanitized_result
            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "returncode": -1,
                    "stdout": "",
                    "stderr": f"Command timed out after {timeout} seconds"
                }
            except Exception as e:
                return {
                    "success": False,
                    "returncode": -1,
                    "stdout": "",
                    "stderr": str(e)
                }

        def collect_vm_logs(self, vm_id):
            """Collect various logs for a VM"""
            logs = {
                "startup_log": "",
                "firecracker_log": "",
                "vm_log": "",
                "console_log": "",
                "collected_at": datetime.now().isoformat()
            }
            
            # Try to find log files in common locations
            log_patterns = [
                f"/opt/firecracker/{vm_id}*.log",
                f"/tmp/{vm_id}*.log", 
                f"/var/log/firecracker/{vm_id}*.log",
                f"/opt/firecracker/logs/{vm_id}*.log"
            ]
            
            for pattern in log_patterns:
                try:
                    log_files = glob.glob(pattern)
                    for log_file in log_files:
                        try:
                            with open(log_file, 'r') as f:
                                content = f.read()
                                if 'startup' in log_file.lower():
                                    logs["startup_log"] += content + "\n"
                                elif 'firecracker' in log_file.lower():
                                    logs["firecracker_log"] += content + "\n"
                                elif 'console' in log_file.lower():
                                    logs["console_log"] += content + "\n"
                                else:
                                    logs["vm_log"] += content + "\n"
                        except Exception as e:
                            logger.warning(f"Could not read log file {log_file}: {e}")
                except Exception as e:
                    logger.debug(f"Could not glob pattern {pattern}: {e}")
            
            # Get process information if VM is running
            try:
                # Try to get process info
                result = subprocess.run(
                    ["ps", "aux"], 
                    capture_output=True, 
                    text=True, 
                    timeout=10
                )
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        if vm_id in line and 'firecracker' in line.lower():
                            logs["vm_log"] += f"Process: {line}\n"
            except Exception as e:
                logger.debug(f"Could not get process info: {e}")
            
            # Sanitize all logs
            for key in logs:
                if isinstance(logs[key], str):
                    logs[key] = self.sanitize_output(logs[key])
            
            return logs

        def get_vm_metrics(self, vm_id):
            """Get metrics for a specific VM"""
            metrics = {
                "vm_id": vm_id,
                "status": "unknown",
                "cpu_usage": 0,
                "memory_usage": 0,
                "network_stats": {},
                "uptime": 0,
                "collected_at": datetime.now().isoformat()
            }
            
            vm_info = self.vms.get(vm_id, {})
            metrics["status"] = vm_info.get("status", "unknown")
            
            # Try to get resource usage if VM is running
            try:
                # Get CPU and memory usage from ps
                result = subprocess.run(
                    ["ps", "aux"], 
                    capture_output=True, 
                    text=True, 
                    timeout=10
                )
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        if vm_id in line and 'firecracker' in line.lower():
                            parts = line.split()
                            if len(parts) >= 4:
                                try:
                                    metrics["cpu_usage"] = float(parts[2])  # %CPU
                                    metrics["memory_usage"] = float(parts[3])  # %MEM
                                except (ValueError, IndexError):
                                    pass
            except Exception as e:
                logger.debug(f"Could not get resource metrics: {e}")
            
            # Calculate uptime
            if "created" in vm_info:
                try:
                    created_time = datetime.fromisoformat(vm_info["created"])
                    uptime_seconds = (datetime.now() - created_time).total_seconds()
                    metrics["uptime"] = uptime_seconds
                except Exception as e:
                    logger.debug(f"Could not calculate uptime: {e}")
            
            return metrics

        def create_vm(self, vm_spec):
            """Create a Firecracker VM using host bridge networking"""
            vm_id = vm_spec.get("vm_id", f"vm-{int(time.time())}")
            github_url = vm_spec.get("github_url", "")
            github_token = vm_spec.get("github_token", "")
            labels = vm_spec.get("labels", "firecracker")
            memory = vm_spec.get("memory_mb", 8192)
            vcpus = vm_spec.get("vcpus", 4)
            ephemeral = vm_spec.get("ephemeral", True)
            
            # Build firecracker-complete.sh launch command
            # Script expects: launch <vm_name> [options]
            args = [
                "launch",
                vm_id,  # VM name as positional argument, not --name
                "--github-url", github_url,
                "--github-token", github_token,
                "--labels", labels,
                "--memory", str(memory),
                "--cpus", str(vcpus),
                "--use-host-bridge",  # Use host br0 bridge
                "--arc-mode",
                "--arc-controller-url", "http://localhost:30080"
            ]
            
            if ephemeral:
                args.append("--ephemeral-mode")
            
            # Execute VM creation
            result = self.execute_script(args, timeout=600)  # 10 minute timeout
            
            if result["success"]:
                # Track VM
                self.vms[vm_id] = {
                    "created": datetime.now().isoformat(),
                    "status": "running",
                    "spec": vm_spec,
                    "networking": "bridge-br0"
                }
                
                # Store creation logs
                self.vm_logs[vm_id] = {
                    "creation_log": result["stdout"],
                    "creation_errors": result["stderr"],
                    "created_at": datetime.now().isoformat()
                }
                
                # Update metrics
                self.metrics["total_vms_created"] += 1
                self.metrics["current_vms"] = len(self.vms)
                
                logger.info(f"VM {vm_id} created successfully")
            else:
                # Update failure metrics
                self.metrics["failed_creations"] += 1
                
                # Store failure logs
                self.vm_logs[vm_id] = {
                    "creation_log": result["stdout"],
                    "creation_errors": result["stderr"],
                    "created_at": datetime.now().isoformat(),
                    "status": "failed"
                }
                
                logger.error(f"Failed to create VM {vm_id}: {result['stderr']}")
            
            return {
                "vm_id": vm_id,
                "success": result["success"],
                "message": result["stderr"] if not result["success"] else "VM created successfully",
                "details": result
            }

        def delete_vm(self, vm_id):
            """Delete a Firecracker VM"""
            args = ["stop", vm_id]
            result = self.execute_script(args)
            
            if vm_id in self.vms:
                self.vms[vm_id]["status"] = "deleted"
                self.vms[vm_id]["deleted_at"] = datetime.now().isoformat()
                
                # Update metrics
                self.metrics["total_vms_deleted"] += 1
                self.metrics["current_vms"] = len([v for v in self.vms.values() if v.get("status") != "deleted"])
            
            # Store deletion logs
            if vm_id not in self.vm_logs:
                self.vm_logs[vm_id] = {}
            
            self.vm_logs[vm_id]["deletion_log"] = result["stdout"]
            self.vm_logs[vm_id]["deletion_errors"] = result["stderr"]
            self.vm_logs[vm_id]["deleted_at"] = datetime.now().isoformat()
            
            return {
                "vm_id": vm_id,
                "success": result["success"],
                "message": result["stderr"] if not result["success"] else "VM deleted successfully"
            }

        def list_vms(self):
            """List all VMs using firecracker-complete.sh"""
            result = self.execute_script(["list"])
            
            return {
                "success": result["success"],
                "vms": self.vms,
                "host_status": result["stdout"],
                "details": result,
                "metrics": self.metrics
            }

        def get_vm_status(self, vm_id):
            """Get status of a specific VM"""
            args = ["status", vm_id]
            result = self.execute_script(args)
            
            vm_info = self.vms.get(vm_id, {})
            
            return {
                "vm_id": vm_id,
                "success": result["success"],
                "status": vm_info.get("status", "unknown"),
                "details": result["stdout"],
                "vm_info": vm_info
            }

        def get_vm_logs(self, vm_id):
            """Get comprehensive logs for a VM"""
            # Collect current logs
            current_logs = self.collect_vm_logs(vm_id)
            
            # Merge with stored logs
            stored_logs = self.vm_logs.get(vm_id, {})
            
            all_logs = {
                **stored_logs,
                **current_logs,
                "vm_id": vm_id
            }
            
            return all_logs

        def get_daemon_metrics(self):
            """Get overall daemon metrics"""
            metrics = self.metrics.copy()
            metrics["current_time"] = datetime.now().isoformat()
            metrics["uptime_seconds"] = (datetime.now() - datetime.fromisoformat(metrics["daemon_start_time"])).total_seconds()
            
            # Add per-VM metrics
            vm_metrics = {}
            for vm_id in self.vms:
                vm_metrics[vm_id] = self.get_vm_metrics(vm_id)
            
            metrics["vm_metrics"] = vm_metrics
            
            return metrics

    class VMDaemonHandler(BaseHTTPRequestHandler):
        def __init__(self, daemon, *args, **kwargs):
            self.daemon = daemon
            super().__init__(*args, **kwargs)

        def log_message(self, format, *args):
            # Use our logger instead of default logging
            logger.info(f"{self.address_string()} - {format % args}")

        def do_GET(self):
            """Handle GET requests"""
            parsed = urlparse(self.path)
            path = parsed.path
            
            try:
                if path == "/health":
                    self.send_json_response({"status": "healthy", "daemon": "firecracker-vm"})
                elif path == "/vms":
                    result = self.daemon.list_vms()
                    self.send_json_response(result)
                elif path == "/metrics":
                    # Get daemon-wide metrics
                    metrics = self.daemon.get_daemon_metrics()
                    self.send_json_response(metrics)
                elif path.startswith("/vms/"):
                    # Parse VM ID and action
                    path_parts = path.strip("/").split("/")
                    if len(path_parts) >= 2:
                        vm_id = path_parts[1]
                        if len(path_parts) == 2:
                            # GET /vms/{vm_id} - VM status
                            result = self.daemon.get_vm_status(vm_id)
                            self.send_json_response(result)
                        elif len(path_parts) == 3:
                            action = path_parts[2]
                            if action == "logs":
                                # GET /vms/{vm_id}/logs - VM logs
                                logs = self.daemon.get_vm_logs(vm_id)
                                self.send_json_response({
                                    "success": True,
                                    "vm_id": vm_id,
                                    "logs": logs
                                })
                            elif action == "metrics":
                                # GET /vms/{vm_id}/metrics - VM metrics
                                metrics = self.daemon.get_vm_metrics(vm_id)
                                self.send_json_response({
                                    "success": True,
                                    "vm_id": vm_id,
                                    "metrics": metrics
                                })
                            else:
                                self.send_error(404, f"Unknown action: {action}")
                        else:
                            self.send_error(404, "Invalid path")
                    else:
                        self.send_error(404, "Invalid VM path")
                else:
                    self.send_error(404, "Not Found")
            except Exception as e:
                logger.error(f"GET error: {e}")
                self.send_error(500, str(e))

        def do_POST(self):
            """Handle POST requests"""
            parsed = urlparse(self.path)
            path = parsed.path
            
            try:
                # Read request body
                content_length = int(self.headers.get('Content-Length', 0))
                body = self.rfile.read(content_length).decode('utf-8') if content_length > 0 else "{}"
                data = json.loads(body)
                
                if path == "/vms":
                    # Create VM
                    result = self.daemon.create_vm(data)
                    self.send_json_response(result, status_code=201 if result["success"] else 400)
                else:
                    self.send_error(404, "Not Found")
            except json.JSONDecodeError:
                self.send_error(400, "Invalid JSON")
            except Exception as e:
                logger.error(f"POST error: {e}")
                self.send_error(500, str(e))

        def do_DELETE(self):
            """Handle DELETE requests"""
            parsed = urlparse(self.path)
            path = parsed.path
            
            try:
                if path.startswith("/vms/"):
                    vm_id = path.split("/")[-1]
                    result = self.daemon.delete_vm(vm_id)
                    self.send_json_response(result)
                else:
                    self.send_error(404, "Not Found")
            except Exception as e:
                logger.error(f"DELETE error: {e}")
                self.send_error(500, str(e))

        def send_json_response(self, data, status_code=200):
            """Send JSON response"""
            response = json.dumps(data, indent=2)
            self.send_response(status_code)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Content-Length', str(len(response)))
            self.end_headers()
            self.wfile.write(response.encode('utf-8'))

    def create_handler(daemon):
        """Create request handler with daemon instance"""
        def handler(*args, **kwargs):
            return VMDaemonHandler(daemon, *args, **kwargs)
        return handler

    def main():
        port = int(os.environ.get("DAEMON_PORT", "8090"))
        work_dir = os.environ.get("FIRECRACKER_WORK_DIR", "/opt/firecracker")
        script_path = os.environ.get("FIRECRACKER_SCRIPT", "/app/firecracker-complete.sh")
        
        # Verify script exists
        if not os.path.exists(script_path):
            logger.error(f"Firecracker script not found at {script_path}")
            logger.info("Available files in /app:")
            try:
                for f in os.listdir("/app"):
                    logger.info(f"  {f}")
            except:
                pass
            exit(1)
        
        # Initialize daemon
        daemon = FirecrackerVMDaemon(work_dir, script_path)
        
        # Create HTTP server
        handler = create_handler(daemon)
        server = HTTPServer(('0.0.0.0', port), handler)
        
        logger.info(f"Firecracker VM Daemon listening on port {port}")
        logger.info(f"Using script: {script_path}")
        logger.info(f"Work directory: {work_dir}")
        logger.info(f"API endpoints:")
        logger.info(f"  GET  /health          - Health check")
        logger.info(f"  GET  /vms             - List all VMs")
        logger.info(f"  GET  /metrics         - Get daemon metrics")
        logger.info(f"  POST /vms             - Create VM")
        logger.info(f"  GET  /vms/{{vm_id}}     - Get VM status")
        logger.info(f"  GET  /vms/{{vm_id}}/logs - Get VM logs")
        logger.info(f"  GET  /vms/{{vm_id}}/metrics - Get VM metrics")
        logger.info(f"  DELETE /vms/{{vm_id}}  - Delete VM")
        
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            logger.info("Shutting down daemon...")
            server.shutdown()

    if __name__ == "__main__":
        main()
